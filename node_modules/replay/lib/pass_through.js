'use strict';

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const HTTP = require('http');
const Zlib = require('zlib');

const ClientRequest = HTTP.ClientRequest;

module.exports = function passThrough(passThroughFunction) {
  if (arguments.length === 0) passThroughFunction = () => true;else if (typeof passThrough === 'string') {
    const hostname = passThroughFunction;
    passThroughFunction = request => request.hostname === hostname;
  } else if (typeof passThroughFunction !== 'function') {
    const truthy = !!passThroughFunction;
    passThroughFunction = () => truthy;
  }

  return function (request, callback) {
    if (passThroughFunction(request)) {
      const options = {
        protocol: request.url.protocol,
        hostname: request.url.hostname,
        port: request.url.port,
        path: request.url.path,
        method: request.method,
        headers: request.headers,
        agent: request.agent,
        auth: request.auth,
        key: request.key,
        cert: request.cert
      };

      const http = new ClientRequest(options);
      if (request.trailers) http.addTrailers(request.trailers);
      http.on('error', callback);
      http.on('response', function (response) {
        const captured = {
          version: response.httpVersion,
          statusCode: response.statusCode,
          statusMessage: response.statusMessage,
          rawHeaders: response.rawHeaders,
          headers: (0, _assign2.default)({}, response.headers),
          body: []
        };
        if (['gzip', 'deflate'].indexOf(captured.headers['content-encoding']) !== -1) {
          const unzip = Zlib.createUnzip();
          unzip.trailers = response.trailers;
          unzip.rawTrailers = response.rawTrailers;
          response = response.pipe(unzip);
          delete captured.headers['content-encoding'];
          delete captured.headers['content-length'];
        }
        response.on('data', function (chunk, encoding) {
          captured.body.push([chunk, encoding]);
        });
        response.on('end', function () {
          captured.trailers = response.trailers;
          captured.rawTrailers = response.rawTrailers;
          callback(null, captured);
        });
      });

      if (request.body) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator3.default)(request.body), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            let part = _step.value;

            http.write(part[0], part[1]);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }http.end();
    } else callback();
  };
};
//# sourceMappingURL=pass_through.js.map
